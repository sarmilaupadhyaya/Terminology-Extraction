Abstract Training neural machine translation models is notoriously slow and requires abundant parallel corpora and computational power . In this work we propose an approach of transferring knowledge from separately trained language models to translation systems also we investigate several techniques to improve translation quality when there is a lack of parallel data and computational resources . Our method is based on fusion between translation system and language model and initialization of translation system with weights from pretrained language models . We show that this technique gives BLEU score on pair of WMT dataset and allows us to reach BLEU on 20k parallel sentences in less than 8 hours of training on a single NVIDIA GeForce GTX 1080 Ti . We specifically note that for this advance we use nothing but monolingual corpora for source and target languages . Significant part of presented results was obtained during hackathon on machine translation organized by iPavlov Lab . 1 Introduction Neural Machine Translation NMT is now a approach for building translation systems . The reason behind this is both the invention of new techniques Bahdanau et 2014 and availability of massive amounts of training data . Despite of abundance of parallel datasets for some popular language pairs we still lack such learning opportunities for many others . That s why there is a growing interest in techniques which allow us to train translation systems in or completely unsupervised fashion . Several notable approaches Conneau et 2017 Artetxe et 2017 Lample et 2017 in this direction were provided in recent years but supervised techniques still highly outperform unsupervised ones . In our work we investigate a approach of combining translation model with language models in two ways . First we propose an approach of initializing a translation model with language models and show how it can be used to advance learning of the whole translation system . Second we revise the technique of shallow fusion by Proceedings of AMTA 2018 Workshop: LoResMT 2018 Boston March 17 21 2018 Page 37 et al . 2015 by using two separate gates to combine predictions of the translation model with predictions of the language model . Using both of these techniques we were able to obtain BLEU on WMT data for pair in comparison to the strong baseline model . Most of the current work was preformed during the hackathon1 on unsupervised machine translation organized by iPavlov Lab2 . Participants were given the task to build translation system . Dataset consisted of 1M monolingual sentences for each of two languages source and target and 50k parallel sentences . The hackathon had an unusual format: instead of submissions where participants are given both training and test data and are asked to send predictions for the test set we had to pack our models into Docker3 containers and send it to the submission server which did all the training and testing on its own side . The purpose of this was to prevent participants from deviating from the hackathon rules by using additional parallel datasets or incorporating some techniques . As the datasets used during the hackathon are private and not available for public use we rerun all our experiments on a dataset specially generated from WMT 14 data see section 4 and all the reported results are obtained from it . In such a way we manage to build a system which learns to translate from English to French in less than 8 hours of training on NVIDIA GeForce GTX 1080 Ti by using only 20k parallel sentences and 300k monolingual corpora . Our system obtains BLEU score showing improvement of BLEU in comparison to the strong baseline model which does not use monolingual corpora . 2 Related work Large amounts of monolingual corpora makes it very appealing to incorporate unsupervised methods into machine translation techniques and in recent years this trend is becoming more and more prominent . Cheng et al . 2016 and Sennrich et al . 2015 propose an approach of backtranslation which is training two translation models: and and then generating synthetic training dataset from monolingual corpora to improve the models . In such a way we incorporate the dual nature of the translation problem . Authors report significant improvement up to BLEU on pair on IWSLT 14 dataset Sennrich et 2015 . et al . 2015 show how one can improve their translation model by shallow or deep fusion of separately trained language model . Let p yt y t be a probability that word of output sequence y is the word of the vocabulary under some model . Here x is the input sentence y t are previous t 1 tokens . In shallow fusion we combine probabilities from target language model and translation model in the following way: log p yt y t log ptrans yt y t β log ptrg yt t where hyperparameter β denotes how much influence language model has for the prediction . In deep fusion authors just concatenate hidden states of the translation model and language model and the whole thing keeping parameters of the language model freeze . Mikolov et al . 2013 used distributed representations of words to learn a linear mapping between vector spaces of languages and showed that this mapping can serve as a good dictionary between the languages . They pick 5k most frequent words from the source language xi 5000 1http : 2http : 3https: Proceedings of AMTA 2018 Workshop: LoResMT 2018 Boston March 17 21 2018 Page 38 and looked up their translations yi 5000 via Google Translate . Afterwards they used them to find a linear mapping W which minimizes P5000 k Wxi yi This linear mapping W was later utilized as the translation mapping to generate a dictionary between two vocabularies and proved to be rather accurate giving almost 90 precision . Lample et al . 2017 extended the approach of Mikolov et 2013 and trained a Generative Adversarial Network GAN model to find this mapping without any supervised signal whatsoever . Generator was set to be this linear mapping while discriminator should distinct between y and yˆ Wx . This approach worked out: learning random bijection was impossible because of linearity and learning a bad linear mapping was impossible because many source words would be mapped to nowhere which is heavily penalized by discriminator . Authors report precision which is a significant result for purely unsupervised approach . Artetxe et al . 2017 built upon described methods to train translation model without any parallel corpora at all . They trained a shared encoder which should encode sentences into the representations and then two separate decoders to reconstruct them into the desired language . To make the encoding task authors add noise to the input sentence: they randomly swap words forcing encoder to learn internal structure of the sentence . They also use backtranslation procedure to make model learn to translate . This approach obtained BLEU on pair on WMT 14 dataset . Artetxe et al . 2017 goes further and use adversarial loss to train their translation system . They build a single shared encoder and a single shared decoder using both denoising autoencoder loss and adversarial loss . Corrupted version of the sentence is given to the encoder and its original form is reconstructed by the decoder . Discriminator takes encoder s outputs and tries to guess which language was given to the encoder . Backtranslation is also used to teach model to translate . Such an approach shows striking performance obtaining BLEU on pair of dataset . Zoph et al . 2016 experimented with transferring different components of the translation model trained on a rich language pair parent model to a NMT system child model . Such a pretraining proved to be a very strong prior for the child model parameters and improved performance by an average of BLEU . 3 Proposed approach Our method is built upon Transformer Vaswani et 2017 architecture which proved to be a fast and powerful machine translation model . In the original paper Transformer was trained entirely on a parallel data . In our work we propose several improvements over it which allows us to exploit monolingual corpora and learn in fashion . Transformer model Transformer Vaswani et 2017 has general architecture but unlike RNNbased models it is purely attentional . it does not keep any internal hidden state which is recurrently updated and all computations are done with tokens representations . Transformer takes a sequence as an input makes several iterations to encode it and then several attentional iterations to decode it . Attention mechanism scaled attention in its general form is defined as: Attention Q K V d V where Q is some query matrix individual queries are packed into a query matrix K is the keys which are used to process the query V are the values to be retrieved . Transformer uses multiple Proceedings of AMTA 2018 Workshop: LoResMT 2018 Boston March 17 21 2018 Page 39 attention heads: MultiHead Q K V head1 headh WO where headi Attention QWQ i KW K i V WV i . For translation setup we usually set Q K V z1 zk where zi is the sequence element on the current iteration . Scaling factor d improves numerical stability and does not allow model to be pushed to regions with flat gradients . Each time attentional layer is computed we apply a ReLU with residual connections . As Transformer does not possess any recurrent state it needs to know a position of each token some other way . For this purpose we add a positional embedding pi to each token zi which elements are computed as: pi j sin 2j d j is even cos 2j d j is odd . Initializing transformer with language models Originally transformer is trained in a purely supervised fashion which limits its use to problems with abundant parallel corpora . We mitigate this problem the following way . We take two monolingual corpora for each language source and target separately train Transformer s encoder as a language model for the source language its decoder as a language model for the target language and then the whole thing on a parallel corpus to learn a translation task . In this way our method can be seen as a transfer learning technique . Language model LM is tasked to predict the next token given the sequence of previous ones . Let psrc xs s θsrc ptrg yt t θtrg denote language models for source and target languages ptrans y t θ denote our Transformer . Source LM is parametrized as Transformer s encoder but with additional linear output transformation to generate logits target LM as its decoder but without encoder s outputs attention weights . One can notice that a lot of weights between θ and θsrc θtrg can be shared: θ does not need final output connection from hidden state to logits of the source LM which θsrc disposes and additionally it needs attention weights for encoder outputs from the decoder which θtrg lacks . All other weights can be transferred from language models to the translation model right away . In such a way we transfer knowledge extracted by language models from large monolingual corpora to our translation system . Transformer architecture with proposed initialization approach is represented on figure . Gated shallow fusion We further improve our model by incorporating language knowledge in the process of generating output sequence . In such a way we follow a strategy of shallow fusion proposed by et al . 2015 but instead of adding hyperparameter β we use gated shallow fusion . Let log ptrans yt y t log ptrg yt t denote logits for output token produced by translation transformer and LM of the target language respectively . We generate final predictions log p yt y t in the following manner: log p yt y t σ t trans log ptrans yt y t σ t lm log ptrg yt t where σ t trans σ t lm 0 1 are gates which let the overall system choose between two models . Both gates are produced by a network with one hidden layer and two output neurones: σ t trans σ t lm FFN s t trans Proceedings of AMTA 2018 Workshop: LoResMT 2018 Boston March 17 21 2018 Page 40 Figure 1: Proposed Transformer architecture . We color components whose weights are initialized with source LM weights in green and with target LM in blue . We use two separate gates σtrans and σlm instead of using a single one and gating with σ and 1 σ because it gives more accurate calibration between the language model and translation model . During training in this setup we freeze language model weights and translation model should learn when and how much it should trust language model . 4 Setup In this section we describe datasets we used for testing our models preprocessing steps and model parameters . Results are presented in the next section . Datasets To introduce repeatable results we reproduced all experiments on famous WMT for pair . This corpus consists of almost 2M parallel sentences so we were able to extract parallel data test set and monolingual corporas for language models from it . Important thing here is that we choose monolingual corporas from different parts of original parallel corpora so they do not contain similar information . Also we made experiments with different sizes of parallel corpora . We name datasets according to the size of the parallel corpus and language pair see table 1 . At the same time we used private dataset from DeepHack hackathon which consists of descriptions of hotels in English and Russian as parallel corporas and comments about hotels as monolingual ones . The size of the parallel corpora for this set was originally 50k and monolingual corporas were 1M each but we reduced them to be the same size as datasets . We use validation set to prevent overfitting and reduce training time . Training process stops when the BLEU score on validation set does not improve for five epochs . The model with best validation BLEU at that moment is a final one . We report final result on 5k parallel sentences used as test set . Proceedings of AMTA 2018 Workshop: LoResMT 2018 Boston March 17 21 2018 Page 41 Dataset Corpus En Fr Parallel train 0 20k 0 20k Parallel validation Parallel test 50 55k 50 55k Monolingual En 200 500k Monolingual Fr 1M Parallel train 0 10k 0 10k Parallel validation Parallel test 50 55k 50 55k Monolingual En 200 500k Monolingual Fr 1M Table 1: Data splits from original for pair Preprocessing We use the following preprocessing procedure . 1 . First we tokenize all data with standard NLTK4 package for python . 2 . Second we apply encoding Sennrich et 2015 to reduce the size of the dictionary . This step is done using library . For pair we use joint vocabulary of size 32k . And for we use separate vocabularies 4k each . Vocabularies are fixed for all datasets and for all datasets . Default model For translation model we follow general transformer architecture Vaswani et 2017 but as we were highly constrained by time and computational resources during the hackathon we had 8 hours on NVIDIA GeForce GTX 1080 Ti for preprocessing training and inference we had to reduce several values . Model we used had the following parameters for all experiments: All embeddings had size d 512 hidden layer of FFN applied to embeddings in between attentional layers had 2048 neurons . We used 4 attentional heads and 4 attentional layers . Our dropout rates were chosen to be for attention ReLU and residual connections . As an optimizer we used Adam optimizer with initial learning rate being equal 1e 4 and β2 . Weights are randomly initialized with normal distribution with mean 0 and standard deviation being equal 5 Results In this section we evaluate all variations of model on several datasets to see how our models profits from fusion and initialization with language models . 20k experiments6 We start from evaluating four main models on and datasets . The training progress for pair is shown on Fig . 2 . The final results for both pairs on a test set are listed in table 2 . We can notice that models with initialization perform reasonably better than models without it . Also we see that initialization is essential if we use fusion . All training process for 20k data fits in 5 hours on GTX 1080 Ti and a huge part of this time is used by validation after each epoch . 4http : 5https : 620k parallel train sentences 1k parallel validation sentences 300k monolingual corporas Proceedings of AMTA 2018 Workshop: LoResMT 2018 Boston March 17 21 2018 Page 42 Figure 2: Training process for dataset Model BLEU BLEU Transformer Transformer with LM initialization Transformer without LM initialization with fusion Transformer with LM initialization and fusion Table 2: Results on 20k datasets 10k experiments During this series of experiments we see again that proposed approach improves BLEU score . Also it is worth to mention that for fused model this initialization is essential to achieve any reasonable score . Finally it is important to notice that due to extremely small parallel corpora models tend to do a lot of factual mistakes in translations which is shown well by BLEU score . Model BLEU BLEU Transformer Transformer with LM initialization Transformer without LM initialization with fusion 5 Transformer with LM initialization and fusion Table 3: Results on 10k datasets 6 Discussion and Conclusion In this work we presented an approach of initializing translation model with language models and a new technique for shallow fusion of LM into translation system . These approaches allow to improve existing NMT in the situations when there is a lack of parallel data by only using monolingual corpora . We experimentally showed an improvement up to BLEU for the Transformer model on one of the setups . However we must notice that human review of translations for pair where our model outperformed standard transformer by BLEU does Proceedings of AMTA 2018 Workshop: LoResMT 2018 Boston March 17 21 2018 Page 43 not show any significant advantage of our approach . All of the proposed models perform quite well on short sentences and provide almost the same translations but on the sentences longer than 15 words translations become notably different and with different mistakes . Also we see that the performance of our version of fusion is not always good so this approach is yet to be analyzed . Acknowledgment We thank iPavlov laboratory for organizing hackathon and providing us data and computational resources to do the work.